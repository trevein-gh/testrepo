[Потребности от фреймворка]
- simple, error-free DOM event/model driven manipulation
- simple code modularity, especially arbitrary code.
- testability
- build tools
- low to none js server side 


[Выбор фреймворка]

1. Backbone.js
- минималистический
- заточен на single-page
- возможен boilerplate
- mvc есть


2. Angular.js
- two-way binding. More than O(N) slow
- 36k package
- attach to DOM functionality
- Dependency injection (services), testable
- suitable for back-enders (Java-experience)
- lots of DOM updates on model update
- only one way to work with a framework
- steep learning curve
- designed for web forms
- no cache precompiled views
- переход с 1 на 2 версию

3. Ember
- родословная связь с Ruby on Rails
- 95 кб, плюс jQuery и Handlebars
- should do "Ember way" (convention over configuration)
- built-in templating library, routing, etc
- Ember CLI (debugging?)
- a lot of generated code, so learning curve is steep
- two-way data-binding, faster than Angular
- no server-side rendering

4. React
- 120 kb, no dependencies
- fast (VDOM, synthetic events)
- easy to learn. No DSL
- component-based (!? CommonJS or no?), easy mixing them.
- server-side rendering
- no pure HTML, it's all encapsulated in components. No templates.
- immutability, app-state-dependency only, easy undo, pure fucntions.


[Система сборки]

React.
- Нужен ли ES 6? - если да, см. Babel (Babelify)
	-- пока нет. Это может усложнить наладку проекта; при необходимости, babelify трансформация подключается в browserify.
- Gulp
- Browserify или Reactify?

[многопоточность]
	- Promise (rsvp, es6, Q)
	- coroutines (Q.spawn, task.js, co)
		http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/
		- node-fibers
			- что такое Future?
		- проблема с консистентностью состояния генератора
	- generators (es6, rsvp?)
		- полифиллы?
			- babel-polyfill. + runtime (см. документацию babel)
		- использовать yield можно только статически в генераторе, в коллбэках нельзя.
	- взаимодействие с updateQueue
		- process.nextTick для освобождения управления
	
	
	Достаточно много информации здесь: http://www.2ality.com
		http://www.2ality.com/2015/03/es6-generators.html
		http://www.2ality.com/2015/03/no-promises.html - список статей


=============================================================================================================================


18.05.16
[prototype]

!TODO
- Проброс ошибок! Пока места, где нужно его организовать, прикрыты //ERROR
- первый шаг выполнять в CodeRunner.run(), а не update()
- сейчас инициализируются только глобальные процедуры, хорошо бы это делать и для процедур черепашек (у них тоже есть!). Или склеивать все в один лист?
- who на разных страницах (сейчас код в Prims некорректный)

!low
- drawQueue переделать на memory-efficient
- сделать удобный в использовании AssetLoader, чтобы не писать код на каждую текстуру



- !info меняет ли click текущую черепашку?	-- да. Но после этого(!) who сохраняется для процесса, и на внешний мир не влияет.

	
18.05.16
Начал писать на es6 синтаксисе. Всё равно придётся использовать генераторы...

19.05.16
Реализую line wrap. Сейчас есть опасность получить бесконечный цикл, надо быть осторожным... Мб. поставить failsafe на количество итераций.
Разумеется, это не работает, пограничные случаи вылезают. Нужно более надёжное решение.

Кстати по PIXI.Graphics: это набор точек (линий), которые отрисовываются в Canvas его методами. Возможно, можно включить кэширование как битмэпа.

Реализовал более надёжный перенос линий.
Однако не удалось разобраться с cacheAsBitmap; без него через некоторое время fps падает из-за разросшегося объекта graphics.
Наверное, можно отрисовывать текущую очередь в текстуру и очищать graphics. По-прежнему вопрос, нужна ли очередь? :) Пока оставлена, чтобы разносить update и draw.

20.05.16
Циклические зависимости! Наконец я налетел на них :) Попробую вынести подключение зависящих от App модулей в рантайм (после создания экспорта App)
Да, работает хорошо. Все модули зависят от экспорта App, а он не зависит от модулей :)

23.05.16
СФ хочет, чтобы код выполнялся максимально быстро, а не за константное время. Два раза пройтись по очереди (120 фпс) помогает ускорить до привычных значений; полноценный максимально-быстрый код потребует некоторого редизайна главного цикла. А это не раньше, чем будет написан код корутин.

24.05.16

[Вложенные генераторы]
Концепция работает, есть написанный пример. Наткнулся на низкую скоростью setInterval(...,0) - действительно надо повышать частоту атомарных операций. Грубо замерил скорость цикла вложенных генераторов, 1кк итераций в секунду есть. Хорошо бы также разделять "мгновенные" функции/примитивы, и "долгие". Как? Табличка в коде, табличка отдельно, соглашения именования?
Также пора подумать над неймспейсами.

25.05.16
[namespace]
Неймспейсы реализованы.
Это:
	globals.prims
	globals.userproc
	globals.vars

Предполагается, что translatedCode(globals, obj) начинается с:
				var prims = globals.prims;
				var vars = globals.vars;
				var userproc = globals.userproc;
для удобства.
Объявление myproc: 
				userproc['myproc'] = function* (){...}
				

Вызов myproc:
				yield* userproc['myproc']();

[генераторы]
CodeRunner на генераторах реализован.
Если prim.fd() генератор, то вызов: 
				yield* prims.fd(100);	//isGenerator = true
И в генераторе для паузы:
				yield* turtles[i].prim_fd(val);	//delegate pause to prim implementation
				... (Turtle.prim_fd() - вложенный генератор)
					yield;	//relinquish control
Если не поставить yield на нижнем вложенном уровне, управление не передаётся. Можно это использовать для единообразной реализации примитивов через генераторы: если нужно выполнять мгновено, yield* вызывается, но вложенного yield; нет.

Если не генератор, yield не ставится, идёт обычный вызов функции:
				prim.tto();
Но возможно, см. выше про единообразное исполнение примитивов. При этом хорошо бы понять, что происходит с функциями (сейчас передача результата идёт через update loop)
	-- да, если во вложенном генераторе не вызывается yield, то паузы не происходит. Т.е. можно все вызовы примитивов писать через:
	
		var result = yield* primname();
	
	При этом primname должно быть генератором; если primname возвращает значение И вызывает yield, то возврат значения делается так:
		
		return yield returnExpression;	//на самом деле нет, см. ниже
	
	Важный момент: yield надо брать в скобки, т.к. yield 1 + 2 эквивалентно yield (1+2). Впрочем, это относится ко всему порядку операций в джаваскрипте.
	!! Словил странную проблему: возвращаемое значение генератора вызывает ошибку в yield*, лечится созданием отдельной переменной для результата (похоже на проблему оптимизатора):
		var result = x;
		return result;
	
[wait]
Ок, теперь можно реализовать wait. Это выглядит посложнее, чем параллельно бегающие черепашки...
А именно, паузу на процесс может ставить только CodeRunner, изнутри невозможно - или мы не передаём управление, или мы продолжаем итерации дальше.
Хотя... мы можем поставить бесконечные итерации генератора. Не самое производительное решение - мы выполняем некоторую работу на каждый update цикл для каждого потока. С другой стороны, обычный for-loop всё равно будет проходить по очереди. Кстати, это решение надёжнее, чем setTimeout, который может застать очередь в неопределённом (остановленном, уничтоженном) состоянии.
Если паузу ставить будет CodeRunner, надо получить к нему доступ из wait. Т.е. надо придумать проброс объекта CodeRunner в исполняемый код, и в частности в wait. Можно и наоборот, наружу - через результат yield.

[балансировка нагрузки]
Близкий к оптимальному режим - 1 миллисекунда update cycle, 10 итераций в каждом. Попытка динамического баланса на основе panic флага из mainloop.js провалилась; требуется более тщательное ручное вычисление задержек.
Большое количество (20+) одновременных черепашек плеер не глотает (benchmarkTurtles() в loader'е).

[неймспейсы переменных]
Надо дописать неймспейс Globals.vars, с методами let и thing и make.
!? какое значение должно возвращаться, если значения нет? Пока возвращается null.
-- реализованы. В начале процедуры объявляется 
	var scope = vars.newLocalScope();
	и работа с переменными происходит через scope.let("a",1); scope.make("a",1); scope.thing("a");
	
[управляющие примитивы]
	if-else переводится буквально.
	repeat 10 [...] с помощью for (let i ...) + yield
		-- аргумент repeat должен быть иммутабелен в ходе выполнения цикла!

26.05.16
В MWEx у черепашек есть свои процедуры и они переопределяют глобальные. Если у черепашки есть процедура, и черепашка есть в who, то выполняется её процедура. 

[балансировка нагрузки]
Реализовал проход по очереди кусками за отведённое время. Дополнительно изменяется simulationTimestep при падении fps. Балансировка simulationTimestep довольно грубая, рывки заметны. Требуется потом переписать более плавную регулировку, с подстройкой оптимальных значений.
Текущая производительность - 100к - 150к задач в очереди за секунду.

Попробовал переместить TurtlePrims в статический класс, с привязкой по apply. Получилось достаточно сложное решение, потянувшее за собой библиотеку [co] (для выполнения генератора из обычной функции). Но в итоге оказалось, что obj.prim_name больше неприменимы, а связывание who в процессе пока не реализовано. Так что надо делать простое решение, с созданием объекта для каждой черепашки. 
	-- или нет.

01.05.16
[процессы]
Добавился новый параметр у translatedCode - processContext, в котором сохраняется локальное для процесса who
С ним реализован forever, запускающий новые "процессы".

02.05.16
[стыковка с транслятором]
1) подгрузка дерева проекта из внешнего файла
2) сборка плеера в production mode
3) опционально: упрощённый формат подгружаемого кода (реализовать комманд центр)

(2) gulp deploy отрабатывает, но uglify отключен - используемая версия не поддерживает es6.
Ужасно большой размер подключённого browserify-shim (100 kb)

Реализовать home, seth :arg, setpos [x y],
И настало время для carefully

07.05.16
Оформил новую версию доков по интерфейсам и реализованным примитивам.

10.06.16
!TODO Требуется реализовать механизм вызова примитивов из других примитивов! Сейчас это невозможно.
Изображение черепашки перенесено на imgur.
'who' ставится правильно при щелчках и запуске CodeRunner'а (берётся из проекта, при щелчке ставится в проект).
!! в глобальном процессе who должен быть ссылкой на глобальный who, а не его копией!
	-- это понадобится, когда будут реализовываться штуки, дающие к нему доступ. Например, startup.
Доделаны аргументы пользовательских процедур, подробности в документации.

Требуется реализовать ошибки, и графику (формы).


21.06.14
(ранее)
Ошибки реализованы простым try-catch, он добавляется функцией-обёрткой к translatedCode.
Реализован FileLoader, однако с локального компьютера не даёт пользоваться из-за ограничений. Так что дополнительно реализован эмбеддинг бинарных данных через base64
У шейпов подменяются прозрачные пиксели.
Спрайт черепашки раскрашивается с помощью colorMatrix.

22.06.14
[Загрузка картинок]
Проблема с CORS достаточно серьёзная. Картинки можно размещать только на сервере с открытым CORS; на ботсаде сходу поставить его не получилось. С imgur скачивать картинки можно, но нельзя полагаться на определённое имя (например, идея с именем картинки равным её хэшу).
Пока отложено, до обсуждения формата проекта.

Реализован stopall; он просто удаляет все задачи, поддержки паузы OnTick нет.
Также: clickoff, stopme(processContext)


19.07.14
base64 загружается нормально; json загружается нормально.
Сделана распаковка картинок targa в текстуры. По-хорошему, надо редактирование прозрачности делать не на текстуре, а на распакованном битмэпе.
Шейпы сейчас представляют ссылки на (прозрачные) текстуры битмэпов. Сейчас это неважно, в будущем может понадобиться родная структура шейпов (ссылка на оргинальный битмэп, с хэшем, и всё такое).

22.07.14
Баг в браузере/pixi.
В WebGL рендерере: 
рисование спрайта в RenderTexture и создание текстуры мз его канваса приводит к потере альфы, изображение сложено с чёрным фоном. Этот баг не удалось победить, но можно обойти, возвращая отредактированную рендертекстуру вместо новой обычной.
В Canvas рендерере: не работают шейдеры colormatrix, черепашки не раскрашиваются.

Как получить буковки с массива:
(Array.prototype.slice.call(new Uint8Array(signature.buffer))).map((c)=>String.fromCharCode(c))

27.07.14
Реализация страниц потребовала уточнения who.
Считаем, что page.curturtle содержит черепашки с текущей страницы! (на самом деле нет)

Политика обработки событий. Нужно ли запускать каждый раз обработчик в новом таске, или проглатывать события, пока таск обработчика не освободится?

28.07.14
!INFO
Структура слоёв в Логомирах:

template-freeze или template-bg-color (обычно 0 - прозрачный. Может быть полупрозрачным.)
template-buffer (обычно 0xffffffff)
page-freeze или page-bg-color (обычно 0 - прозрачный)
page-buffer

Структура слоёв в плеере сейчас (требуется доработка, как минимум учитывать bg-color!)

stage-bg
pageBgLayer
canvasDraw

05.08.16
События onColor сейчас срабатывают после перемещения в fd.
Черепашка таскается. Хиттест работает на непрозрачных пикселях - возможно, надо увеличить зону попадания. 
!TODO 
	- Также нужно проверить на увеличенных шейпах - может не работать.
	- нужно ввести флаг временных координат, т.к. координаты могут перерисовываться при событиях, например.
	
Сейчас делается пересечение шейпов.
При перетаскивании надо делать черепашку главной.
Когда таскается - все процессы должны вставать на паузу! То же с паузой при аннонсе.

08.08.16
userproc:
	- нужно сделать полное дерево вложенности (сейчас два уровня, нужно переделать реализацию процедур)
	- нужно ли передавать явно аргументы?
	- реализовать черепашьи процедуры
			-- инициализация сейчас делается в initAfterRestore - насколько это корректно?
			-- глобальные переменные черепашки совпадают с проектом - это правильно?
	- сделать человеческое сообщение об ошибке, если процедура не найдена
	- ужасно медленное рисование звёздочки. Оптимизировать!
В итоге: не наследовать стек переопределений переменных - нормально. Черепашьи процедуры запускать в черепашьих раннерах, глобальные - в глобальном. Реализовать возврат значений функций!

12.09.16
Сейчас события срабатывают последовательно: пока событие обрабатывается, оно не триггерится. В ЛМ, напротив, onTouching запускает параллельные процессы.
!TODO Реализовать следующую логику onTouching: проверять для всех черепашек, запоминать их; для каждой запустить параллельный процесс и не запускать его повторно, пока он работает; также не запускать повторно для черепашки, которой мы продолжаем касаться. Плюс, запускать onTouching для касаемой черепашки.
!BUG события срабатывают на следующей итерации очереди ПОСЛЕ породившего процесса. Хорошо бы им срабатывать сразу!

28.09.16
!INFO
Как в MWEX реализованы ask, tto с черепашьими процедурами:
ask [t1 t2][someresult]
выполняет последовательно, возвращает результат 1-й черепашки, если он есть; два результата - ошибка.

tto [t1][t2] someresult
выполняет параллельно, результаты не возвращает, ждёт конца выполнения. В списке процессов не появляется! Черепашьи процедуры друг друга тоже вызывают таким образом.

06.12.16
